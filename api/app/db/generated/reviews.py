# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: reviews.sql
from collections.abc import AsyncIterator, Iterator

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.generated import models

CREATE_REVIEW = """-- name: create_review \\:one
INSERT INTO reviews (
    toilet_id, content, rating_water_pressure, rating_cleanliness,
    rating_poopability, has_bidet, is_approved, upvotes, downvotes, photos
)
VALUES (
           :p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9, :p10
       )
RETURNING id, created, modified, toilet_id, content, rating_water_pressure, rating_cleanliness, rating_poopability, has_bidet, is_approved, upvotes, downvotes, photos
"""


class CreateReviewParams(pydantic.BaseModel):
    toilet_id: str
    content: str | None
    rating_water_pressure: int
    rating_cleanliness: int
    rating_poopability: int
    has_bidet: bool
    is_approved: bool
    upvotes: int
    downvotes: int
    photos: list[str] | None


DELETE_REVIEW = """-- name: delete_review \\:one
DELETE
FROM reviews
WHERE id = :p1
RETURNING id
"""


GET_REVIEW = """-- name: get_review \\:one
SELECT id, created, modified, toilet_id, content, rating_water_pressure, rating_cleanliness, rating_poopability, has_bidet, is_approved, upvotes, downvotes, photos
FROM reviews
WHERE id = :p1
"""


LIST_REVIEWS = """-- name: list_reviews \\:many
SELECT id, created, modified, toilet_id, content, rating_water_pressure, rating_cleanliness, rating_poopability, has_bidet, is_approved, upvotes, downvotes, photos
FROM reviews
"""


LIST_TOILET_REVIEWS = """-- name: list_toilet_reviews \\:many
SELECT id, created, modified, toilet_id, content, rating_water_pressure, rating_cleanliness, rating_poopability, has_bidet, is_approved, upvotes, downvotes, photos
FROM reviews
WHERE toilet_id = :p1
"""


UPDATE_REVIEW = """-- name: update_review \\:one
UPDATE reviews
SET toilet_id             = COALESCE(:p1, toilet_id),
    content               = COALESCE(:p2, content),
    rating_water_pressure = COALESCE(:p3, rating_water_pressure),
    rating_cleanliness    = COALESCE(:p4, rating_cleanliness),
    rating_poopability    = COALESCE(:p5, rating_poopability),
    has_bidet             = COALESCE(:p6, has_bidet),
    is_approved           = COALESCE(:p7, is_approved),
    upvotes               = COALESCE(:p8, upvotes),
    downvotes             = COALESCE(:p9, downvotes),
    photos                = COALESCE(:p10, photos)
WHERE id = :p11
RETURNING id, created, modified, toilet_id, content, rating_water_pressure, rating_cleanliness, rating_poopability, has_bidet, is_approved, upvotes, downvotes, photos
"""


class UpdateReviewParams(pydantic.BaseModel):
    toilet_id: str | None
    content: str | None
    rating_water_pressure: int | None
    rating_cleanliness: int | None
    rating_poopability: int | None
    has_bidet: bool | None
    is_approved: bool | None
    upvotes: int | None
    downvotes: int | None
    photos: list[str] | None
    id: str


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_review(self, arg: CreateReviewParams) -> models.Review | None:
        row = self._conn.execute(
            sqlalchemy.text(CREATE_REVIEW),
            {
                "p1": arg.toilet_id,
                "p2": arg.content,
                "p3": arg.rating_water_pressure,
                "p4": arg.rating_cleanliness,
                "p5": arg.rating_poopability,
                "p6": arg.has_bidet,
                "p7": arg.is_approved,
                "p8": arg.upvotes,
                "p9": arg.downvotes,
                "p10": arg.photos,
            },
        ).first()
        if row is None:
            return None
        return models.Review(
            id=row[0],
            created=row[1],
            modified=row[2],
            toilet_id=row[3],
            content=row[4],
            rating_water_pressure=row[5],
            rating_cleanliness=row[6],
            rating_poopability=row[7],
            has_bidet=row[8],
            is_approved=row[9],
            upvotes=row[10],
            downvotes=row[11],
            photos=row[12],
        )

    def delete_review(self, *, id: str) -> str | None:
        row = self._conn.execute(sqlalchemy.text(DELETE_REVIEW), {"p1": id}).first()
        if row is None:
            return None
        return row[0]

    def get_review(self, *, id: str) -> models.Review | None:
        row = self._conn.execute(sqlalchemy.text(GET_REVIEW), {"p1": id}).first()
        if row is None:
            return None
        return models.Review(
            id=row[0],
            created=row[1],
            modified=row[2],
            toilet_id=row[3],
            content=row[4],
            rating_water_pressure=row[5],
            rating_cleanliness=row[6],
            rating_poopability=row[7],
            has_bidet=row[8],
            is_approved=row[9],
            upvotes=row[10],
            downvotes=row[11],
            photos=row[12],
        )

    def list_reviews(self) -> Iterator[models.Review]:
        result = self._conn.execute(sqlalchemy.text(LIST_REVIEWS))
        for row in result:
            yield models.Review(
                id=row[0],
                created=row[1],
                modified=row[2],
                toilet_id=row[3],
                content=row[4],
                rating_water_pressure=row[5],
                rating_cleanliness=row[6],
                rating_poopability=row[7],
                has_bidet=row[8],
                is_approved=row[9],
                upvotes=row[10],
                downvotes=row[11],
                photos=row[12],
            )

    def list_toilet_reviews(self, *, toilet_id: str) -> Iterator[models.Review]:
        result = self._conn.execute(
            sqlalchemy.text(LIST_TOILET_REVIEWS), {"p1": toilet_id}
        )
        for row in result:
            yield models.Review(
                id=row[0],
                created=row[1],
                modified=row[2],
                toilet_id=row[3],
                content=row[4],
                rating_water_pressure=row[5],
                rating_cleanliness=row[6],
                rating_poopability=row[7],
                has_bidet=row[8],
                is_approved=row[9],
                upvotes=row[10],
                downvotes=row[11],
                photos=row[12],
            )

    def update_review(self, arg: UpdateReviewParams) -> models.Review | None:
        row = self._conn.execute(
            sqlalchemy.text(UPDATE_REVIEW),
            {
                "p1": arg.toilet_id,
                "p2": arg.content,
                "p3": arg.rating_water_pressure,
                "p4": arg.rating_cleanliness,
                "p5": arg.rating_poopability,
                "p6": arg.has_bidet,
                "p7": arg.is_approved,
                "p8": arg.upvotes,
                "p9": arg.downvotes,
                "p10": arg.photos,
                "p11": arg.id,
            },
        ).first()
        if row is None:
            return None
        return models.Review(
            id=row[0],
            created=row[1],
            modified=row[2],
            toilet_id=row[3],
            content=row[4],
            rating_water_pressure=row[5],
            rating_cleanliness=row[6],
            rating_poopability=row[7],
            has_bidet=row[8],
            is_approved=row[9],
            upvotes=row[10],
            downvotes=row[11],
            photos=row[12],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_review(self, arg: CreateReviewParams) -> models.Review | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_REVIEW),
                {
                    "p1": arg.toilet_id,
                    "p2": arg.content,
                    "p3": arg.rating_water_pressure,
                    "p4": arg.rating_cleanliness,
                    "p5": arg.rating_poopability,
                    "p6": arg.has_bidet,
                    "p7": arg.is_approved,
                    "p8": arg.upvotes,
                    "p9": arg.downvotes,
                    "p10": arg.photos,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Review(
            id=row[0],
            created=row[1],
            modified=row[2],
            toilet_id=row[3],
            content=row[4],
            rating_water_pressure=row[5],
            rating_cleanliness=row[6],
            rating_poopability=row[7],
            has_bidet=row[8],
            is_approved=row[9],
            upvotes=row[10],
            downvotes=row[11],
            photos=row[12],
        )

    async def delete_review(self, *, id: str) -> str | None:
        row = (
            await self._conn.execute(sqlalchemy.text(DELETE_REVIEW), {"p1": id})
        ).first()
        if row is None:
            return None
        return row[0]

    async def get_review(self, *, id: str) -> models.Review | None:
        row = (
            await self._conn.execute(sqlalchemy.text(GET_REVIEW), {"p1": id})
        ).first()
        if row is None:
            return None
        return models.Review(
            id=row[0],
            created=row[1],
            modified=row[2],
            toilet_id=row[3],
            content=row[4],
            rating_water_pressure=row[5],
            rating_cleanliness=row[6],
            rating_poopability=row[7],
            has_bidet=row[8],
            is_approved=row[9],
            upvotes=row[10],
            downvotes=row[11],
            photos=row[12],
        )

    async def list_reviews(self) -> AsyncIterator[models.Review]:
        result = await self._conn.stream(sqlalchemy.text(LIST_REVIEWS))
        async for row in result:
            yield models.Review(
                id=row[0],
                created=row[1],
                modified=row[2],
                toilet_id=row[3],
                content=row[4],
                rating_water_pressure=row[5],
                rating_cleanliness=row[6],
                rating_poopability=row[7],
                has_bidet=row[8],
                is_approved=row[9],
                upvotes=row[10],
                downvotes=row[11],
                photos=row[12],
            )

    async def list_toilet_reviews(
        self, *, toilet_id: str
    ) -> AsyncIterator[models.Review]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_TOILET_REVIEWS), {"p1": toilet_id}
        )
        async for row in result:
            yield models.Review(
                id=row[0],
                created=row[1],
                modified=row[2],
                toilet_id=row[3],
                content=row[4],
                rating_water_pressure=row[5],
                rating_cleanliness=row[6],
                rating_poopability=row[7],
                has_bidet=row[8],
                is_approved=row[9],
                upvotes=row[10],
                downvotes=row[11],
                photos=row[12],
            )

    async def update_review(self, arg: UpdateReviewParams) -> models.Review | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(UPDATE_REVIEW),
                {
                    "p1": arg.toilet_id,
                    "p2": arg.content,
                    "p3": arg.rating_water_pressure,
                    "p4": arg.rating_cleanliness,
                    "p5": arg.rating_poopability,
                    "p6": arg.has_bidet,
                    "p7": arg.is_approved,
                    "p8": arg.upvotes,
                    "p9": arg.downvotes,
                    "p10": arg.photos,
                    "p11": arg.id,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Review(
            id=row[0],
            created=row[1],
            modified=row[2],
            toilet_id=row[3],
            content=row[4],
            rating_water_pressure=row[5],
            rating_cleanliness=row[6],
            rating_poopability=row[7],
            has_bidet=row[8],
            is_approved=row[9],
            upvotes=row[10],
            downvotes=row[11],
            photos=row[12],
        )
