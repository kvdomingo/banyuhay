# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: toilets.sql
from collections.abc import AsyncIterator, Iterator
from typing import Any

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from app.db.generated import models

CREATE_TOILET = """-- name: create_toilet \\:one
INSERT INTO toilets (
    establishment_name, geometry, location_information, avg_rating_water_pressure, avg_rating_cleanliness,
    avg_rating_poopability, total_reviews, has_bidet, upvotes, downvotes, photos
)
VALUES (
           :p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9, :p10, :p11
       )
RETURNING id, created, modified, establishment_name, geometry, location_information, avg_rating_water_pressure, avg_rating_cleanliness, avg_rating_poopability, total_reviews, has_bidet, upvotes, downvotes, photos
"""


class CreateToiletParams(pydantic.BaseModel):
    establishment_name: str
    geometry: Any
    location_information: str
    avg_rating_water_pressure: float
    avg_rating_cleanliness: float
    avg_rating_poopability: float
    total_reviews: int
    has_bidet: bool
    upvotes: int
    downvotes: int
    photos: list[str] | None


DELETE_TOILET = """-- name: delete_toilet \\:one
DELETE
FROM toilets
WHERE id = :p1
RETURNING id
"""


GET_TOILET = """-- name: get_toilet \\:one
SELECT id, created, modified, establishment_name, geometry, location_information, avg_rating_water_pressure, avg_rating_cleanliness, avg_rating_poopability, total_reviews, has_bidet, upvotes, downvotes, photos
FROM toilets
WHERE id = :p1
"""


LIST_TOILETS = """-- name: list_toilets \\:many
SELECT id, created, modified, establishment_name, geometry, location_information, avg_rating_water_pressure, avg_rating_cleanliness, avg_rating_poopability, total_reviews, has_bidet, upvotes, downvotes, photos
FROM toilets
"""


UPDATE_TOILET = """-- name: update_toilet \\:one
UPDATE toilets
SET establishment_name        = COALESCE(:p1, establishment_name),
    geometry                  = COALESCE(:p2, geometry),
    location_information      = COALESCE(:p3, location_information),
    avg_rating_water_pressure = COALESCE(:p4, avg_rating_water_pressure),
    avg_rating_cleanliness    = COALESCE(:p5, avg_rating_cleanliness),
    avg_rating_poopability    = COALESCE(:p6, avg_rating_poopability),
    total_reviews             = COALESCE(:p7, total_reviews),
    has_bidet                 = COALESCE(:p8, has_bidet),
    upvotes                   = COALESCE(:p9, upvotes),
    downvotes                 = COALESCE(:p10, downvotes),
    photos                    = COALESCE(:p11, photos)
WHERE id = :p12
RETURNING id, created, modified, establishment_name, geometry, location_information, avg_rating_water_pressure, avg_rating_cleanliness, avg_rating_poopability, total_reviews, has_bidet, upvotes, downvotes, photos
"""


class UpdateToiletParams(pydantic.BaseModel):
    establishment_name: str | None
    geometry: Any | None
    location_information: str | None
    avg_rating_water_pressure: float | None
    avg_rating_cleanliness: float | None
    avg_rating_poopability: float | None
    total_reviews: int | None
    has_bidet: bool | None
    upvotes: int | None
    downvotes: int | None
    photos: list[str] | None
    id: str


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def create_toilet(self, arg: CreateToiletParams) -> models.Toilet | None:
        row = self._conn.execute(
            sqlalchemy.text(CREATE_TOILET),
            {
                "p1": arg.establishment_name,
                "p2": arg.geometry,
                "p3": arg.location_information,
                "p4": arg.avg_rating_water_pressure,
                "p5": arg.avg_rating_cleanliness,
                "p6": arg.avg_rating_poopability,
                "p7": arg.total_reviews,
                "p8": arg.has_bidet,
                "p9": arg.upvotes,
                "p10": arg.downvotes,
                "p11": arg.photos,
            },
        ).first()
        if row is None:
            return None
        return models.Toilet(
            id=row[0],
            created=row[1],
            modified=row[2],
            establishment_name=row[3],
            geometry=row[4],
            location_information=row[5],
            avg_rating_water_pressure=row[6],
            avg_rating_cleanliness=row[7],
            avg_rating_poopability=row[8],
            total_reviews=row[9],
            has_bidet=row[10],
            upvotes=row[11],
            downvotes=row[12],
            photos=row[13],
        )

    def delete_toilet(self, *, id: str) -> str | None:
        row = self._conn.execute(sqlalchemy.text(DELETE_TOILET), {"p1": id}).first()
        if row is None:
            return None
        return row[0]

    def get_toilet(self, *, id: str) -> models.Toilet | None:
        row = self._conn.execute(sqlalchemy.text(GET_TOILET), {"p1": id}).first()
        if row is None:
            return None
        return models.Toilet(
            id=row[0],
            created=row[1],
            modified=row[2],
            establishment_name=row[3],
            geometry=row[4],
            location_information=row[5],
            avg_rating_water_pressure=row[6],
            avg_rating_cleanliness=row[7],
            avg_rating_poopability=row[8],
            total_reviews=row[9],
            has_bidet=row[10],
            upvotes=row[11],
            downvotes=row[12],
            photos=row[13],
        )

    def list_toilets(self) -> Iterator[models.Toilet]:
        result = self._conn.execute(sqlalchemy.text(LIST_TOILETS))
        for row in result:
            yield models.Toilet(
                id=row[0],
                created=row[1],
                modified=row[2],
                establishment_name=row[3],
                geometry=row[4],
                location_information=row[5],
                avg_rating_water_pressure=row[6],
                avg_rating_cleanliness=row[7],
                avg_rating_poopability=row[8],
                total_reviews=row[9],
                has_bidet=row[10],
                upvotes=row[11],
                downvotes=row[12],
                photos=row[13],
            )

    def update_toilet(self, arg: UpdateToiletParams) -> models.Toilet | None:
        row = self._conn.execute(
            sqlalchemy.text(UPDATE_TOILET),
            {
                "p1": arg.establishment_name,
                "p2": arg.geometry,
                "p3": arg.location_information,
                "p4": arg.avg_rating_water_pressure,
                "p5": arg.avg_rating_cleanliness,
                "p6": arg.avg_rating_poopability,
                "p7": arg.total_reviews,
                "p8": arg.has_bidet,
                "p9": arg.upvotes,
                "p10": arg.downvotes,
                "p11": arg.photos,
                "p12": arg.id,
            },
        ).first()
        if row is None:
            return None
        return models.Toilet(
            id=row[0],
            created=row[1],
            modified=row[2],
            establishment_name=row[3],
            geometry=row[4],
            location_information=row[5],
            avg_rating_water_pressure=row[6],
            avg_rating_cleanliness=row[7],
            avg_rating_poopability=row[8],
            total_reviews=row[9],
            has_bidet=row[10],
            upvotes=row[11],
            downvotes=row[12],
            photos=row[13],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_toilet(self, arg: CreateToiletParams) -> models.Toilet | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_TOILET),
                {
                    "p1": arg.establishment_name,
                    "p2": arg.geometry,
                    "p3": arg.location_information,
                    "p4": arg.avg_rating_water_pressure,
                    "p5": arg.avg_rating_cleanliness,
                    "p6": arg.avg_rating_poopability,
                    "p7": arg.total_reviews,
                    "p8": arg.has_bidet,
                    "p9": arg.upvotes,
                    "p10": arg.downvotes,
                    "p11": arg.photos,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Toilet(
            id=row[0],
            created=row[1],
            modified=row[2],
            establishment_name=row[3],
            geometry=row[4],
            location_information=row[5],
            avg_rating_water_pressure=row[6],
            avg_rating_cleanliness=row[7],
            avg_rating_poopability=row[8],
            total_reviews=row[9],
            has_bidet=row[10],
            upvotes=row[11],
            downvotes=row[12],
            photos=row[13],
        )

    async def delete_toilet(self, *, id: str) -> str | None:
        row = (
            await self._conn.execute(sqlalchemy.text(DELETE_TOILET), {"p1": id})
        ).first()
        if row is None:
            return None
        return row[0]

    async def get_toilet(self, *, id: str) -> models.Toilet | None:
        row = (
            await self._conn.execute(sqlalchemy.text(GET_TOILET), {"p1": id})
        ).first()
        if row is None:
            return None
        return models.Toilet(
            id=row[0],
            created=row[1],
            modified=row[2],
            establishment_name=row[3],
            geometry=row[4],
            location_information=row[5],
            avg_rating_water_pressure=row[6],
            avg_rating_cleanliness=row[7],
            avg_rating_poopability=row[8],
            total_reviews=row[9],
            has_bidet=row[10],
            upvotes=row[11],
            downvotes=row[12],
            photos=row[13],
        )

    async def list_toilets(self) -> AsyncIterator[models.Toilet]:
        result = await self._conn.stream(sqlalchemy.text(LIST_TOILETS))
        async for row in result:
            yield models.Toilet(
                id=row[0],
                created=row[1],
                modified=row[2],
                establishment_name=row[3],
                geometry=row[4],
                location_information=row[5],
                avg_rating_water_pressure=row[6],
                avg_rating_cleanliness=row[7],
                avg_rating_poopability=row[8],
                total_reviews=row[9],
                has_bidet=row[10],
                upvotes=row[11],
                downvotes=row[12],
                photos=row[13],
            )

    async def update_toilet(self, arg: UpdateToiletParams) -> models.Toilet | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(UPDATE_TOILET),
                {
                    "p1": arg.establishment_name,
                    "p2": arg.geometry,
                    "p3": arg.location_information,
                    "p4": arg.avg_rating_water_pressure,
                    "p5": arg.avg_rating_cleanliness,
                    "p6": arg.avg_rating_poopability,
                    "p7": arg.total_reviews,
                    "p8": arg.has_bidet,
                    "p9": arg.upvotes,
                    "p10": arg.downvotes,
                    "p11": arg.photos,
                    "p12": arg.id,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Toilet(
            id=row[0],
            created=row[1],
            modified=row[2],
            establishment_name=row[3],
            geometry=row[4],
            location_information=row[5],
            avg_rating_water_pressure=row[6],
            avg_rating_cleanliness=row[7],
            avg_rating_poopability=row[8],
            total_reviews=row[9],
            has_bidet=row[10],
            upvotes=row[11],
            downvotes=row[12],
            photos=row[13],
        )
